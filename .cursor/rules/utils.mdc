---
description: Rules for utility functions
globs: {app/utils,shared/utils}/**/*.ts
alwaysApply: false
---
# Utility Function Rules

Guidelines for utility functions.

## Scope & Dependencies

- Never import from `app/composables`, `app/stores`, Vue core, GraphQL client, or anything requiring runtime reactivity.

## Purity & Determinism

- Functions must be pure: no I/O, no mutation of external objects, no reading time/random/env directly.
- If time or randomness needed, accept them as parameters (`now: () => number`, `rand: () => number`).

## Side Effects (Prohibited)

- No logging (`console.*`), network calls, storage access, DOM, timers, or process/env mutation.
- Memoization only if: documented, idempotent, and safe across concurrent calls.

## API Design

- One responsibility per function; split when a second unrelated concern appears.
- Naming: `verb + Noun` or `noun + To + Noun` (e.g., `formatDurationMs`, `orderIdToString`).
- Order parameters: primary data first, options object last; avoid positional boolean flags.
- Accept objects instead of widening parameter lists after 3 required params.

## Input Validation & Error Model

- Validate preconditions; do not silently coerce invalid input.
- Expected failures: prefer a `Result` union (`{ ok: true; value } | { ok: false; error }`) or return `undefined` with documented semantics; avoid throwing for routine domain conditions.
- Throws reserved for programmer errors / invariant violations (use an `assert` helper pattern).

## Immutability & Data Shapes

- Return new objects/arrays; never leak internal mutable references.
- Mark output collections `ReadonlyArray<T>` (or `readonly T[]`) when mutation is not part of contract.
- Use branded types for distinct IDs or units when mixing similar primitives risks bugs.

## Performance Discipline

- Do not microâ€‘optimize without evidence (profile or bench). Add a `*.bench.ts` only for proven hot paths.
- Avoid premature caching; introduce only after demonstrating repeated expensive computation.
- Prefer clarity over cleverness; only refactor to a more complex form if benchmark shows material improvement.

## Documentation

- JSDoc every exported function: purpose (Japanese), parameter semantics, return type, error/Result contract.
- Include `@example` for non-trivial transformations or formatting.
- Document invariants (e.g., "Assumes input ISO string is UTC").

## Anti-Patterns (Avoid)

- Chaining multiple utility types instead of defining a named intermediate type.
- Overloaded signatures where clearer separate functions would suffice.
- Hiding side effects behind innocuous names (e.g., `getConfig()` that reads disk/env).
- Returning partially valid objects (use a failure branch instead).

---
Short checklist for code review:

1. Pure (no side effects, deterministic)?
2. Clear naming & single responsibility?
3. Input validated & error model explicit?
4. No premature optimization / caching?
5. Tests cover success + failure + edge cases?
6. JSDoc documents contract & example?
7. Suitable location (still a generic util)?
